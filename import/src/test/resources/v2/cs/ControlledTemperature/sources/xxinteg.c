/**********************************************************
 * This file is generated by 20-sim ANSI-C Code Generator
 *
 *  file:  src\xxinteg.c
 *  subm:  ControlledTemperature
 *  model: ControlledTemperature_2
 *  expmt: ControlledTemperature_2
 *  date:  June 19, 2017
 *  time:  4:45:33 PM
 *  user:  Controllab Internal
 *  from:  Controllab Products B.V., 20-sim 4.7 Professional Single
 *  build: 4.7.1000.7863
 **********************************************************/

/* This file describes the integration methods
   that are supplied for computation.

   Currently the following methods are supported:
   * Euler
   * RungeKutta2
   * RungeKutta4
   * Vode Adams
   but it is easy for the user to add their own
   integration methods with these two as an example.
*/

/* the system include files */
#include <stdlib.h>
#include <string.h>
#include <math.h>

/* our own include files */
#include "xxinteg.h"
#include "xxmodel.h"

#define xx_STATE_SIZE 1

#define FMI_LOG_ERROR(mi,message)	if (mi->fmiCallbackFunctions != NULL && mi->fmiCallbackFunctions->logger != NULL)\
	{\
		mi->fmiCallbackFunctions->logger(NULL, "ControlledTemperature", fmi2Error, "error",\
			message);\
	}


/*********************************************************************
 * RungeKutta4 integration method
 *********************************************************************/

/*********************************************************************
 * the initialization of the RungeKutta4 integration method
 */
static const XXDouble OneOverSix = 1.0 / 6.0;

XXBoolean XXRungeKutta4Initialize (xx_ModelInstance* model_instance)
{
	/* empty our static arrays */
	memset (model_instance->q0, 0, xx_STATE_SIZE * sizeof (XXDouble));
	memset (model_instance->q1, 0, xx_STATE_SIZE * sizeof (XXDouble));
	memset (model_instance->q2, 0, xx_STATE_SIZE * sizeof (XXDouble));
	memset (model_instance->q3, 0, xx_STATE_SIZE * sizeof (XXDouble));
	memset (model_instance->q4, 0, xx_STATE_SIZE * sizeof (XXDouble));
	return XXTRUE;
}

/* the termination of the RungeKutta4 integration method */
XXBoolean XXRungeKutta4Terminate (xx_ModelInstance* model_instance)
{
	/* nothing yet (our arrays are static) */
	return XXTRUE;
}

/* the Runge-Kutta-4 integration method itself */
XXBoolean XXRungeKutta4Step (xx_ModelInstance* model_instance, XXDouble outputTime)
{
	XXInteger index;
	XXDouble rktime;
	xx_ModelInstance *mi = model_instance;
	XXDouble output_time = mi->m_use_finish_time ? (mi->finish_time > outputTime ? outputTime : mi->finish_time) : outputTime;

	/* check if we have to limit our stepsize to get exactly at the outpuTime */
	XXDouble stepSize = model_instance->step_size;
	if( output_time - model_instance->time < stepSize )
	{
		/* limit the step size */
		stepSize = output_time - model_instance->time;
	}

	/* This model has 1 states */
	/*********************************************************************************/
	/*          calculate intermediate state results q1, q2, q3 and q4               */
	/*********************************************************************************/

	/* cache the simulation time */
	rktime = model_instance->time;

	/* the q0 will hold the value of the last evaluation. This is used multiple times
	   so remember the complete state array in this vector. */
	memcpy (model_instance->q0, model_instance->s, xx_STATE_SIZE * sizeof (XXDouble));

	/* calculate q1 = f (states, t) * dt  =  rates * dt  */
	for (index = 0; index < xx_STATE_SIZE; index++)
	{
		/* set the intermediate q1 */
		model_instance->q1 [index] = model_instance->R [index] * stepSize;

		/* set the new states to use  for q2 */
		model_instance->s [index] = model_instance->q0 [index] + model_instance->q1 [index] / 2;
	}

	/* calculate q2 = f (states + q1 / 2, t + dt / 2) * dt  */
	model_instance->time = rktime + 0.5 * stepSize;

	model_instance->major = XXFALSE;

	XXCalculateDynamic (model_instance);
	memcpy (model_instance->q2, model_instance->R, xx_STATE_SIZE * sizeof (XXDouble));

	/* for each state */
	for (index = 0; index < xx_STATE_SIZE; index++)
	{
		/* set the ultimate q2 */
		model_instance->q2 [index] = model_instance->q2 [index] * stepSize;

		/* set the new states to use */
		model_instance->s [index] = model_instance->q0 [index] + model_instance->q2 [index] / 2;
	}

	/* calculate q3 = f (states + q2 / 2, t + dt / 2) * dt  */
	XXCalculateDynamic (model_instance);
	memcpy (model_instance->q3, model_instance->R, xx_STATE_SIZE * sizeof (XXDouble));

	/* for each state */
	for (index = 0; index < xx_STATE_SIZE; index++)
	{
		/* set the ultimate q3 */
		model_instance->q3 [index] = model_instance->q3 [index] * stepSize;

		/* set the new states */
		model_instance->s [index] = model_instance->q0 [index] + model_instance->q3 [index];
	}

	/* calculate q4 = f (states + q3, t + dt) * dt */
	model_instance->time = rktime + stepSize;
	XXCalculateDynamic (model_instance);
	memcpy (model_instance->q4, model_instance->R, xx_STATE_SIZE * sizeof (XXDouble));

	/* for each state */
	for (index = 0; index < xx_STATE_SIZE; index++)
	{
		/* set the ultimate q4 */
		model_instance->q4 [index] = model_instance->q4 [index] * stepSize;

		/*********************************************************************************/
		/*          calculate the next state from the intermediate results               */
		/*********************************************************************************/

		/* calculate the next state = classical Runge-Kutta integration step */
		model_instance->s[index] = model_instance->q0[index] + (model_instance->q1[index] + model_instance->q2[index] + model_instance->q2[index] + model_instance->q3[index] + model_instance->q3[index] + model_instance->q4[index]) * OneOverSix;
	}

	model_instance->major = XXTRUE;

	/* evaluate the derivative model to calculate the new rates */
	XXCalculateDynamic (model_instance);
	return XXTRUE;
}
