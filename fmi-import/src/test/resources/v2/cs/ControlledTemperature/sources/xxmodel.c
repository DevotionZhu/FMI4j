/**********************************************************
 * This file is generated by 20-sim ANSI-C Code Generator
 *
 *  file:  src\xxmodel.c
 *  model: ControlledTemperature_2
 *  expmt: ControlledTemperature_2
 *  date:  June 19, 2017
 *  time:  4:45:33 PM
 *  user:  Controllab Internal
 *  from:  Controllab Products B.V., 20-sim 4.7 Professional Single
 *  build: 4.7.1000.7863
 **********************************************************/

/* This file contains the actual model variables and equations */

/* Note: Alias variables are the result of full optimization
   of the model in 20-sim. As a result, only the real variables
   are used in the model for speed. The user may also include
   the alias variables by adding them to the end of the array:

   XXDouble xx_variables[NUMBER_VARIABLES + NUMBER_ALIAS_VARIABLES + 1];
   XXCharacter *xx_variable_names[] = {
     VARIABLE_NAMES, ALIAS_VARIABLE_NAMES, NULL
   };

   and calculate them directly after the output equations:

   void XXCalculateOutput (void)
   {
     OUTPUT_EQUATIONS
     ALIAS_EQUATIONS
   }
*/

/* system include files */
#include <stdlib.h>
#include <math.h>

/* 20-sim include files */
#include "xxmodel.h"
#include "xxfuncs.h"


#if (18 > 8192) && defined _MSC_VER
#pragma optimize("", off)
#endif
/* this method is called before calculation is possible */
void XXModelInitialize (xx_ModelInstance* model_instance)
{
	/* set the parameters */
	xx_P[0] = 0.1;		/* HeatCapacity1\C {J/K} */
	xx_P[1] = 298.0;		/* HeatCapacity1\T0 {K} */
	xx_P[2] = 2.0;		/* OnOffController\bandwidth {K} */
	xx_P[3] = 4.16667;		/* Ramp\slope {1/s} */
	xx_P[4] = 8.0;		/* Ramp\start_time {s} */
	xx_P[5] = 16.0;		/* Ramp\stop_time {s} */
	xx_P[6] = 298.15;		/* Ramp\offset */
	xx_P[7] = 5.0e6;		/* Switch\R1\R {ohm} */
	xx_P[8] = 5.0e6;		/* Switch\R2\R {ohm} */
	xx_P[9] = 1.0e-5;		/* Switch\Resistance12\Ron {ohm} */
	xx_P[10] = 100000.0;		/* Switch\Resistance12\Roff {ohm} */
	xx_P[11] = 0.5;		/* Switch\Resistance12\vt */
	xx_P[12] = 293.15;		/* TemperatureSource\T {K} */
	xx_P[13] = 0.1;		/* ThermalConductor\G {W/K} */
	xx_P[14] = 10.0;		/* Thermistor\R_ref {ohm} */
	xx_P[15] = 293.15;		/* Thermistor\T_ref {K} */
	xx_P[16] = 0.004;		/* Thermistor\alpha {} */
	xx_P[17] = 10.0;		/* VoltageSource\U {V} */


	/* set the initial values */
	xx_I[0] = 0.0;		/* HeatCapacity1\p.dQ_int_initial {J} */


	/* set the states */
	xx_s[0] = xx_I[0];		/* HeatCapacity1\p.dQ_int {J} */


}
#if (18 > 8192) && defined _MSC_VER
#pragma optimize("", on)
#endif

/* This function calculates the initial equations of the model.
 * These equations are calculated before anything else
 */
void XXCalculateInitial (xx_ModelInstance* model_instance)
{
		/* OnOffController\currentState = 0.0; */
		xx_V[4] = XXFALSE;

		/* OnOffController\newState = 0.0; */
		xx_V[5] = XXFALSE;


	/* set the states */
	xx_s[0] = xx_I[0];		/* HeatCapacity1\p.dQ_int {J} */


}

/* This function calculates the static equations of the model.
 * These equations are only dependent from parameters and constants
 */
void XXCalculateStatic (xx_ModelInstance* model_instance)
{
	/* Ground\p.u = 0; */
	xx_V[0] = 0.0;

	/* Switch\Ground1\p.u = 0; */
	xx_V[7] = 0.0;

	/* Switch\Ground2\p.u = 0; */
	xx_V[8] = 0.0;

	/* TemperatureSource\p.T = TemperatureSource\T; */
	xx_V[17] = xx_P[12];

	/* VoltageSource\p.u = VoltageSource\U; */
	xx_V[24] = xx_P[17];

	/* ZeroJunction\p1.dQ = 0; */
	xx_V[26] = 0.0;

	/* VoltageSource\p_high.u = Ground\p.u + VoltageSource\p.u; */
	xx_V[25] = xx_V[0] + xx_V[24];

	/* Switch\R1\p.u = VoltageSource\p_high.u - Switch\Ground1\p.u; */
	xx_V[10] = xx_V[25] - xx_V[7];

	/* Switch\R1\p.i = Switch\R1\p.u / Switch\R1\R; */
	xx_V[11] = xx_V[10] / xx_P[7];

}

/* This function calculates the input equations of the model.
 * These equations are dynamic equations that must not change
 * in calls from the integration method (like random and delay).
 */
void XXCalculateInput (xx_ModelInstance* model_instance)
{

}

/* This function calculates the dynamic equations of the model.
 * These equations are called from the integration method
 * to calculate the new model rates (that are then integrated).
 */
void XXCalculateDynamic (xx_ModelInstance* model_instance)
{
	/* HeatCapacity1\E = HeatCapacity1\p.dQ_int + HeatCapacity1\C * HeatCapacity1\T0; */
	xx_V[3] = xx_s[0] + xx_P[0] * xx_P[1];

	/* HeatCapacity1\p.T = HeatCapacity1\E / HeatCapacity1\C; */
	xx_V[2] = xx_V[3] / xx_P[0];

	/* Ramp\output = Ramp\slope * (ramp (Ramp\start_time) - ramp (Ramp\stop_time)) + Ramp\offset; */
	xx_V[6] = xx_P[3] * (XXRamp (xx_P[4], xx_time) - XXRamp (xx_P[5], xx_time)) + xx_P[6];

	/* ThermalConductor\p.T = TemperatureSource\p.T - HeatCapacity1\p.T; */
	xx_V[18] = xx_V[17] - xx_V[2];

	/* ThermalConductor\p.dQ = ThermalConductor\p.T * ThermalConductor\G; */
	xx_V[19] = xx_V[18] * xx_P[13];

	/* Thermistor\R = Thermistor\R_ref * (1 + Thermistor\alpha * (HeatCapacity1\p.T - Thermistor\T_ref)); */
	xx_V[23] = xx_P[14] * (1.0 + xx_P[16] * (xx_V[2] - xx_P[15]));

	/* if (major) */
	if (xx_major)
	{
		/* OnOffController\newState = (OnOffController\currentState and HeatCapacity1\p.T < (Ramp\output + OnOffController\bandwidth / 2)) or HeatCapacity1\p.T < (Ramp\output - OnOffController\bandwidth / 2); */
		xx_V[5] = (xx_V[4] && xx_V[2] < (xx_V[6] + xx_P[2] / 2.0)) || xx_V[2] < (xx_V[6] - xx_P[2] / 2.0);

		/* OnOffController\currentState = OnOffController\newState; */
		xx_V[4] = xx_V[5];
	}

	/* Switch\Resistance12\R = (if OnOffController\newState > Switch\Resistance12\vt then Switch\Resistance12\Ron else Switch\Resistance12\Roff end); */
	xx_V[16] = ((xx_V[5] > xx_P[11]) ? 
		/* Switch\Resistance12\Ron */
		xx_P[9]
	:
		/* Switch\Resistance12\Roff */
		xx_P[10]
	);

	/* Switch\Node1\p3.i = ((VoltageSource\p_high.u - Ground\p.u) / Thermistor\R + (VoltageSource\p_high.u - Switch\Ground2\p.u) / Switch\R2\R) / (1.0 + (Switch\Resistance12\R / Thermistor\R + Switch\Resistance12\R / Switch\R2\R)); */
	xx_V[29] = ((xx_V[25] - xx_V[0]) / xx_V[23] + (xx_V[25] - xx_V[8]) / xx_P[8]) / (1.0 + (xx_V[16] / xx_V[23] + xx_V[16] / xx_P[8]));

	/* Switch\Resistance12\p.u = Switch\Resistance12\R * Switch\Node1\p3.i; */
	xx_V[14] = xx_V[16] * xx_V[29];

	/* Switch\Node2\p3.i = Switch\R1\p.i + Switch\Node1\p3.i; */
	xx_V[9] = xx_V[11] + xx_V[29];

	/* Switch\Resistance12\p_low.u = VoltageSource\p_high.u - Switch\Resistance12\p.u; */
	xx_V[15] = xx_V[25] - xx_V[14];

	/* Thermistor\p_el.u = Switch\Resistance12\p_low.u - Ground\p.u; */
	xx_V[20] = xx_V[15] - xx_V[0];

	/* Thermistor\p_el.i = Thermistor\p_el.u / Thermistor\R; */
	xx_V[21] = xx_V[20] / xx_V[23];

	/* Thermistor\p_th.dQ = Thermistor\p_el.i * Thermistor\p_el.u; */
	xx_V[22] = xx_V[21] * xx_V[20];

	/* HeatCapacity1\p.dQ = (Thermistor\p_th.dQ + ThermalConductor\p.dQ) - ZeroJunction\p1.dQ; */
	xx_R[0] = (xx_V[22] + xx_V[19]) - xx_V[26];

	/* Switch\R2\p.u = Switch\Resistance12\p_low.u - Switch\Ground2\p.u; */
	xx_V[12] = xx_V[15] - xx_V[8];

	/* Switch\R2\p.i = Switch\R2\p.u / Switch\R2\R; */
	xx_V[13] = xx_V[12] / xx_P[8];

	/* Ground\p.i = Thermistor\p_el.i - Switch\Node2\p3.i; */
	xx_V[1] = xx_V[21] - xx_V[9];


	/* increment the step counter */
	model_instance->steps++;
}

/* This function calculates the output equations of the model.
 * These equations are not needed for calculation of the rates
 * and are kept separate to make the dynamic set of equations smaller.
 * These dynamic equations are called often more than one time for each
 * integration step that is taken. This makes model computation much faster.
 */
void XXCalculateOutput (xx_ModelInstance* model_instance)
{
	/* Temperature_Reference = Ramp\output; */
	xx_V[27] = xx_V[6];

	/* Temperature_Room = HeatCapacity1\p.T; */
	xx_V[28] = xx_V[2];

}

/* This function calculates the final equations of the model.
 * These equations are calculated after all the calculations
 * are performed
 */
void XXCalculateFinal (xx_ModelInstance* model_instance)
{

}

/* this method is called after all calculations are performed */
void XXModelTerminate(xx_ModelInstance* model_instance)
{
}


